<?php
// $Id: esi.module,v 1.2 2010/11/17 11:37:25 manarth Exp $
/**
 * @file
 *   Adds support for ESI (Edge-Side-Include) integration, allowing blocks to be\
 *   delivered by ESI, with support for per-block cache times.
 */

// Default interval for rotating the seed key: defaults to change-daily.
define('ESI__DEFAULT_SEED_KEY_ROTATION_INTERVAL', 86400);

// Default ESI setting for blocks: enabled
define('ESI__BLOCK_CONFIG_DEFAULT__IS_ENABLED', FALSE);

// Default TTL for blocks: 5 minutes
define('ESI__BLOCK_CONFIG_DEFAULT__TTL', 300);



/**
 * Implementation of hook_theme().
 */
function esi_theme() {
  return array(
    'esi_tag' => array(
      'arguments' => array('block' => array()),
      'file' => 'esi.theme.inc',
    ),
  );
}

/**
 * Implementation of hook_theme_registry_alter().
 * Override theme('blocks') to apply our ESI handler.
 */
function esi_theme_registry_alter(&$theme_registry) {
  // override the default theme function for theme('blocks').
  $path = drupal_get_path('module', 'esi');
  $theme_registry['blocks']['function'] = 'esi__theme_blocks';
  $theme_registry['blocks']['file'] = 'esi.theme.inc';
  $theme_registry['blocks']['include files'] = array( "./{$path}/esi.theme.inc");
  $theme_registry['blocks']['theme path']  = $path;
  $theme_registry['blocks']['theme paths'] = array($path);

  // let other modules declare themeable elements eligible for replacement
  // override their rendering to insert ourselves in the process
  $handler = variable_get('esi_theme_handler', 'esi');
  $class = ctools_plugin_load_class('esi', 'plugins', $handler, 'theme_handler');
  if ($class) {
    $ho = new $class(); 
    $values = module_invoke_all('esisource');

    $theme_keys = array_keys($values['theme']);
    foreach ($theme_keys as $theme_key) {
      $theme_registry[$theme_key]['preprocess functions'][] = 'esi_preprocess_esi';
      $ho->theme_paths($theme_registry[$theme_key]['theme paths']);
    }
  }
}

/**
 * 
 */
function esi_preprocess_esi(&$vars, $hook) {
  global $base_path;
  $handler = variable_get('esi_theme_handler', 'esi');
  ctools_include('plugins');
  $class = ctools_plugin_load_class('esi', 'plugins', $handler, 'theme_handler');
  if ($class) {
    $ho = new $class(); 
    if ($ho->send_esi()) {
      $values = module_invoke_all('esisource');
      $esi_settings = $values['theme'][$hook];
      $cachepath = '-';
      if ($esi_settings['cache'] & BLOCK_CACHE_PER_PAGE) {
        $cachepath = base64_encode($_GET['q']);
      }

      $source = $base_path . 'esi/theme/' . $hook . '/' . $cachepath .  _esi__parse_source($values['theme'][$hook]['source arguments']);
      $vars['esi_source'] = $source;
      $ho->preprocess($vars, $esi_settings);
    }
  }
}

/**
 * Callback function to return the plain-text content of a theme function. Given the theme_key
 * it prints the content of the rendered theme element for use as an Edge-side include.
 *
 * @param $theme_key
 *    The string theme key to replace as an edge-side include
 */
function esi__theme_handler($theme_key) {
  $values = module_invoke_all('esisource');
  $esi_data = $values['theme'][$theme_key];
  $arg_pos = 4; // esi/theme/$theme_key/$page/4/5/6/7...

  $callbacks = $esi_data['argument callbacks'];
  $cache = $esi_data['cache'];
  if ($cache & BLOCK_CACHE_PER_PAGE) {
    $_GET['q'] = (base64_decode(arg(3)));
  }
  $callback_vars = array();
  foreach ($callbacks as $callback_data) {
    foreach ($callback_data as $callback_var => $callback) {
      $arg = filter_xss(check_plain(arg($arg_pos)));
      $callback_vars[$callback_var] = $callback($arg);
      ++$arg_pos; 
    }
  }

  $variables = $esi_data['theme variables'];
  $theme_vars = array($theme_key);
  foreach ($variables as $variable => $callback_data) {
    // If this is a scalar that starts with '%', then no callback sould be executed; instead,
    // The corresponding variable in the callback_vars should be used. 
    if(!is_array($callback_data)) {
      $callback_data = ltrim($callback_data, '%');
      $theme_vars[$variable] = $callback_vars[$callback_data];
    } else {
      foreach ($callback_data as $callback => $varnames) {
        $theme_vars[$variable] = call_user_func_array($callback, $callback_vars);
      }
    }
  }

  $handler = variable_get('esi_theme_handler', 'esi');
  ctools_include('plugins');
  $class = ctools_plugin_load_class('esi', 'plugins', $handler, 'theme_handler');
  if ($class) {
    $ho = new $class(); 
    echo $ho->theme($theme_vars, $esi_data);
  }
  return NULL;
}

/**
 * Implementation of hook_menu().
 *   Define a menu-handler.
 */
function esi_menu() {
  return array(
    'esi/block/%' => array(
      'title' => 'ESI Block handler',
      'page callback' => 'esi__block_handler',
      'page arguments' => array(2),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK
    ),
    'esi/theme/%' => array(
      'title' => 'ESI Theme handler',
      'page callback' => 'esi__theme_handler',
      'page arguments' => array(2),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK
    ),
    'admin/settings/esi' => array(
      'title' => 'ESI Configuration',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('esi_settings_form'),
      'access arguments' => array('administer esi settings'),
    )
  );
}


/**
 * Provide configuration form for specifying which plugin to use
 */
function esi_settings_form() {
  $form = array();
  ctools_include('plugins');
  $plugs = ctools_get_plugins('esi', 'plugins');

  $plugin_handlers = array('block_handler' => 'Block',
                           'theme_handler' => 'Theme',
                           #'form_handler' => 'Form'
                          );
  foreach ($plugin_handlers as $handler => $label) {
    $options = array();
    foreach ($plugs as $key => $data) {
      if (isset($data[$handler])) {
        $options[$key] = $data['name'];
      }
    }
    $form['esi_' . $handler] = array(
      '#title' => t('ESI !plugin plugin', array('!plugin' => $label)),
      '#description' => t('Choose the plugin to use for processing !plugin elements', array('!plugin' => $label)),
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => variable_get('esi_' . $handler, 'esi'),
    );
  }
  return (system_settings_form($form));
}


/**
 * Implementation of hook_cron().
 * Every interval, rotate the seed (used to generate the role-cookie).
 * (Each rotation will invalidate the varnish-cache for cached pre-role blocks).
 */
function esi_cron() {
  $age = time() - variable_get('esi_seed_key_last_changed', 0);
  $interval = variable_get('esi_seed_key_rotation_interval', ESI__DEFAULT_SEED_KEY_ROTATION_INTERVAL);
  if ($age > $interval) {
    require_once(dirname(__FILE__) . '/esi.inc');
    _esi__rotate_seed_key();
  }
}


/**
 * Implementation of hook_user().
 *   For maximum cache-efficiency, the proxy must be able to identify the roles
 *   held by a user.  A cookie is used which provides a consistent hash for
 *   all users who share the same roles.
 *   For security, the hash uses a random seed which is rotated (by hook_cron)
 *   at regular intervals - defaults to daily.
 */
function esi_user($op, &$edit, &$account, $category = NULL) {
  // only respond to login/logout.
  if (!($op == 'login' || $op == 'logout')) {
    return;
  }

  // Drupal session cookies use the name 'SESS' followed by an MD5 hash.
  // The role-cookie is the same, prefixes with the letter 'R'.
  $cookie = array('name' => 'R' . session_name());

  if ($op == 'login') {
    require_once(dirname(__FILE__) . '/esi.inc');
    $hash = _esi__get_roles_hash(array_keys($account->roles));
    $lifespan = min(variable_get('esi_seed_key_rotation_interval', ESI__DEFAULT_SEED_KEY_ROTATION_INTERVAL), ini_get('session.cookie_lifetime'));
    $cookie += array(
      'value' => $hash,
      'expire' => time() + $lifespan,
    );
  }
  else {
    $cookie += array(
      'value' => 'deleted',
      'expire' => 1,
    );
  }
  setcookie($cookie['name'], $cookie['value'], $cookie['expire']);
}





/**
 * Implementation of hook_form_FORM_ID_alter().
 * for block_admin_configure
 *   Add ESI-configuration options to the block-config pages.
 */
function esi_form_block_admin_configure_alter(&$form, $form_state) {
  // TODO: describe how the cache configs can be configured as defaults in code.

  // load our helper functions
  require_once(dirname(__FILE__) . '/esi.inc');

  $module = $form['module']['#value'];
  $delta  = $form['delta']['#value'];
  $config = _esi__block_settings($module, $delta);

  $element['esi_config'] = array(
    '#type' => 'fieldset',
    '#title' => t('ESI settings'),
    '#description' => t('Control how this block is cached on an ESI-enabled reverse proxy.'),
    '#tree' => TRUE,
  );

  $element['esi_config']['enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable ESI'),
    '#default_value' => $config->enabled,
  );
 
  $options = _esi__ttl_options($config->ttl);
  $element['esi_config']['ttl'] = array(
    '#type' => 'select',
    '#title' => t('TTL'),
    '#description' => t('Time-to-live on the proxy-cache.'),
    '#options' => $options,
    '#default_value' => $config->ttl,
  );

  // inject our ESI config-fieldset onto the form,
  // just after the 'block_settings' fieldset.
  $i = 1;
  foreach ($form as $key => $value) {
    if ($key == 'block_settings') {
      break;
    }
    $i++;
  }
  $f = array_slice($form, 0, $i);
  $f += $element;
  $f += array_slice($form, $i);
  $form = $f;

  // add a submit-handler to save our config.
  $form['#submit'][] = 'esi__block_config_save';
}

/**
 * Form-submit handler for ESI settings in block-config
 */
function esi__block_config_save($form, $form_state) {
  require_once(dirname(__FILE__) . '/esi.inc');

  $module = $form_state['values']['module'];
  $delta  = $form_state['values']['delta'];

  $config = new stdClass;
  $config->enabled = $form_state['values']['esi_config']['enabled'];
  $config->ttl     = $form_state['values']['esi_config']['ttl'];

  _esi__block_settings($module, $delta, $config);
}


/**
 * Menu handler for ESIs
 *
 * Render a particular block.
 */
function esi__block_handler($bid, $page = NULL) {
  require_once(dirname(__FILE__)  . '/esi.inc');
  $callback = $_GET['q'];
  /**
   * Expect the bid format to be theme:region:module:delta
   * Fail if this doesn't match.
   */
  if (!substr_count($bid, ':') == 3) {
    return FALSE;
  }
  list($theme, $region, $module, $delta) = explode(':', $bid);

  // Block content may change per-page.
  // If this is true for the current block, the origin page url should be
  // provided as an argument.
  if ($page) {
    $_GET['q'] = base64_decode($page);
  }

  // theme set-up.
  // we need to do this manually, because output is echo'd instead of returned.
  init_theme();

  // get the block into a format that can be passed to view-blockk.
  $block = _esi__get_block($theme, $region, $module, $delta);
  /**
   * Pass PER-USER or PER-ROLE cache info to varnish.
   *
   * No-cache is header (TTL) controlled.
   * Per-page is passed as a url argument
   */
  if ($block->cache == BLOCK_NO_CACHE) {
    header("Cache-Control: no-cache, max-age=0");
  }
  elseif ($block->cache & BLOCK_CACHE_PER_USER) {
    // "Cache-control: private" advises proxies that the content is
    // user-specific.  Most proxies will not cache this data - a clever proxy
    // config may make this cacheable.
    header("Cache-Control: private");
  }
  elseif ($block->cache & BLOCK_CACHE_PER_ROLE) {
    header("Cache-Control: private");
  }

  // For all cacheable blocks, set the TTL based on the block config.
  if ($block->cache != BLOCK_NO_CACHE) {
    $config = _esi__block_settings($module, $delta);
    header("Cache-Control: max-age={$config->ttl}");
  }

  $handler = variable_get('esi_block_handler', 'esi');
  ctools_include('plugins');
  $class = ctools_plugin_load_class('esi', 'plugins', $handler, 'block_handler');
  if ($class) {
    $bh = new $class();
    $output = $bh->get_block($callback, $block);
  }
  else {
    $output = theme('block', $block);
  }

  echo $output;
  return NULL;
}

/**
 * turns the information that comes back from an hook_esisource call
 * into  a callback url
 *
 * Currently supported substitutions
 *   %uid into the uid of the current logged in user
 *   %uid_by_path into the uid of the user page currently being viewed
 *   %nid into the nid of the current node
 */
function _esi__parse_source($elements = array()) {
  $new_elements = array();
  foreach ($elements as $element) {
    if (strpos($element, '%') === 0) {
      $element = ltrim($element, '%');
      $func = "_esi_{$element}_get_val";
      if (function_exists($func)) {
        $element = $func();
      }   
    }   
    $new_elements[] = $element;
  }
  return ((!empty($new_elements)) ? '/' . join('/', $new_elements) : '');
}

/**
 * helper function for building URL for ESI eligible theme element callback
 */
function _esi_nid_get_val() {
  if (arg(0) == 'node' && is_numeric(arg(1))) {
    return intval(arg(1));
  }
}

/**
 * helper function for building URL for ESI eligible theme element callback
 */
function _esi_uid_get_val() {
  global $user;
  return $user->uid;
}

function _esi_uid_by_path_get_val() {
  if (arg(0) == 'user' && is_numeric(arg(1))) {
    return intval(arg(1));
  }
}

/**
 * hooks for esi module plugins
 */
function esi_esi_plugins() {
  return array(
    'esi' => array(
      'name' => 'ESI Default Handler',
      'block_handler' => array(
        'class' => 'esi_block',
        'path' => drupal_get_path('module', 'esi') .'/classes',
        'file' => 'esi_block.inc',
      ),

      'theme_handler' => array(
        'class' => 'esi_theme',
        'path' => drupal_get_path('module', 'esi') .'/classes',
        'file' => 'esi_theme.inc',
      ),

      'form_handler' => array(
        'class' => 'esi_form',
        'path' => drupal_get_path('module', 'esi') .'/classes',
        'file' => 'esi_form.inc',
      ),
    ),
  );
}

/**
 * ctools hooks for modules allowing plugins
 */
function esi_ctools_plugin_plugins() {
  return array(
    'use hooks' => TRUE,
  );
}

